**Chapter 03**
https://start-1.tistory.com/37

**Chapter 04**
https://start-1.tistory.com/38

### Chapter 03 네 변수를 알라 ###


#### **변수?**

컵이라고 할 수 있음, 뭔가를 담아두기 위한 용도로 쓰임

변수에는 유형이 있어야 합니다.

변수에는 이름이 있어야 합니다.

변수는 크게 원시 변수와 객체 레퍼런스로 나눌 수 있음


#### **원시 변수?**

자바의 원시 변수 유형도 그 크기가 다양하며 각각 이름이 붙어습니다.
```
int, long, float, double, ...
```


#### **객체 레퍼런스?**

객체 변수라는 것은 없고, 객체 레퍼런스 변수라는 것만 있음

객체 레퍼런스에는 객체에 접근하는 방법을 알려주는 비트가 있음 -> 포인터 같은 것이라고 생각할 수 있음

But, 레퍼런스 변수에 무엇이 들어있는지는 알기 어렵+그저 그 레퍼런스가 객체 단 하나를 가리킨다는 것은 확실

레퍼런스의 크기는 같은 JVM에서는 그 레퍼런스가 참조하는 개체의 크기와는 상관없이 똑같음



#### **객체 선언, 생성 및 대입**

```
Dog myDog = new Dog();
```


**1) 레퍼런스 변수 선언**

1-1) JVM에 레퍼런스 변수용 공간을 할당해달라는 요청

1-2) 그 변수명을 myDog으로 지정함

**2) 객체 생성**

2-1) JVM으로 하여금 힙에 새로운 Dog 객체를 위한 공간 할당 요청

**3) 객체와 레퍼런스의 연결**

3-1) 새로운 Dog 객체를 myDog이라는 레퍼런스 변수에 대입합니다.



#### **원시 변수 VS 객체 레퍼런스**

| 원시 변수 | 객체 레퍼런스 |
| --- | --- |
| 원시 값(ex int a = 7; -> 7) | 레퍼런스 값(리모컨) |



#### **용어 정리**

**힙?**

완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조

힙을 저장하는 표준적인 자료구조는 배열임


#### **가비지 컬랙션 기능?**

가비지 컬랙터가 가비지를 다른 용도로 사용할 수 있도록 메모리 해체를 시켜 메모리를 정리해주는 기능임


#### **가비지는?**

객체가 그 예시 중 하나가 될 수 있음

객체가 레퍼런스 변수와의 연결이 끊어지고 해당 객체를 참조하는 활성 레퍼런스가 없다면,

가비지 컬랙팅의 대상인 가비지가 되는 것


#### **클래스 구성**
객체가 아는 것: 멤버 변수

객체가 하는 것: 멤버 함수



#### **메소드의 매개변수**
-> 매개변수로 전달 받은 경우, 해당 값을 실제로 고치고 싶다면..?
```
int plus(int a, int b){
    a = a + b;
    return a;
}

public static void main(String[] args){
    int a = 3;
    int b = 4;
    plus(a,b);
    
    System.out.println(a);
}
```
여기서 출력되는 값은 7이 아니다.

자바는 값을 전달하기 때문이다.

즉, 복사본을 전달하는 것이다.

a 변수의 주소에 있는 실제 값이 변경되는 것이 아니고,

a 변수의 주소에 있는 실제 값을 복사해서 plus 함수에 전달해준 것 뿐이기에 

저기서 print 되는 값은 7이 아닌, 선언해준 a의 값인 3이 출력되게 된다.



#### **멤버 변수의 캡슐화**
데이터를 아무나 볼 수 있도록, 아무나 건드릴 수 있도록 하면 우리가 원하지 않는 방향에서 데이터 변경이 일어날 수 있기에 조심해야 함



그렇게 하려면! 캡슐화를 진행해야 하는데,

#### **캡슐화란,**

접근 변경자 private을 사용하고, setter 메소드와 getter 메소드를 이용하면

메세징을 통해 바로 멤버 변수를 호출하고 값을 변경할 수 있는 것이 아닌

setter 메소드와 getter 메소드를 통해서만 변경할 수 있게 된다.



#### **캡슐화의 장점?**

1) 제한 검사

만약, 범위나 들어오는 값에 제한을 두어야 하는 경우

이를 setter 메소드에서 검사할 수 있어 오류를 방지할 수 있다.



2) 코드 변경

나중에 뭔가를 변경하더라도 다른 코드는 건드리지 않아도 괜찮음


### Chapter 04 객체의 행동 ###
#### **클래스 구성**
​
객체가 아는 것: 멤버 변수
​
객체가 하는 것: 멤버 함수
​
#### **메소드의 매개변수**
​
\-> 매개변수로 전달 받은 경우, 해당 값을 실제로 고치고 싶다면..?
​
```
int plus(int a, int b){
    a = a + b;
    return a;
}
​
public static void main(String[] args){
    int a = 3;
    int b = 4;
    plus(a,b);
    
    System.out.println(a);
}
```
​
여기서 출력되는 값은 7이 아니다.
​
자바는 값을 전달하기 때문이다.
​
즉, 복사본을 전달하는 것이다.
​
a 변수의 주소에 있는 실제 값이 변경되는 것이 아니고,
​
a 변수의 주소에 있는 실제 값을 복사해서 plus 함수에 전달해준 것 뿐이기에 
​
저기서 print 되는 값은 7이 아닌, 선언해준 a의 값인 3이 출력되게 된다.

​
#### **멤버 변수의 캡슐화**
​
데이터를 아무나 볼 수 있도록, 아무나 건드릴 수 있도록 하면 우리가 원하지 않는 방향에서 데이터 변경이 일어날 수 있기에 조심해야 함
​
그렇게 하려면! 캡슐화를 진행해야 하는데,

​
**캡슐화란,**
​
접근 변경자 private을 사용하고, setter 메소드와 getter 메소드를 이용하면
​
메세징을 통해 바로 멤버 변수를 호출하고 값을 변경할 수 있는 것이 아닌
​
setter 메소드와 getter 메소드를 통해서만 변경할 수 있게 된다.

​
**캡슐화의 장점?**
​
**1) 제한 검사**
​
만약, 범위나 들어오는 값에 제한을 두어야 하는 경우
​
이를 setter 메소드에서 검사할 수 있어 오류를 방지할 수 있다.
​
**2) 코드 변경**
​
나중에 뭔가를 변경하더라도 다른 코드는 건드리지 않아도 괜찮음

​
#### **인스턴스 변수와 지역 변수**
​
**인스턴스 변수**
​
인스턴스 변수는 클래스 내에서 선언됨
​
인스턴스 변수에는 항상 어떤 기본값이 들어가게 됨
​
**지역 변수**
​
지역 변수는 블록 내에서 선언됨
​
지역 변수는 꼭 초기화를 해주어야 함

​
#### **변수 비교**
​
**1) \==** 
​
원시 유형 두 개를 비교
​
레퍼런스 두 개가 같은 객체를 참조하고 있는지 비교
​
```
int a = 3;
int b = 3;
if(a == b){
    System.out.println("똑같습니다.");
}
else{
    System.out.println("다릅니다.");
}
```
​
**2) equals() 메소드**
​
type은 같으나 서로 다른 두 객체가 똑같은지 비교
​
```
String a = "aaa";
String b = "bbb";
​
System.out.println(a.equals(b));
```

