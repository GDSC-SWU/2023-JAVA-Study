## **\[CHAPTER 08\] 심각한 다형성**

### **추상 클래스**

클래스 중에는 인스턴스를 만들면 안 되는 것도 있음

\-> ex) 너무 추상적인 개념을 담고 있는 경우(ex hippo는 구체적인 클래스인데 Animal은 추상적인 클래스)

\-> 이런 경우에는 그냥 class가 아닌 abstract class(추상 클래스)를 만들면 됨

컴파일러에서는 추상 클래스의 인스턴스를 만드는것을 허용하지 않음

그렇다면 추상 클래스의 역할..이.. 뭐죠??

\-> 추상 클래스는 확장하지 않으면 거의 쓸모도 없고, 가치도 없고, 삶의 목적도 없습니다.

추상 클래스를 만들었을 때 실제 실행 중에 일을 처리하는 것은 그 **추상 클래스의 하위클래스 인스턴스** 입니다.

\+ 추상 클래스가 아닌 것을 구상 클래스라고 하는데, 우리가 사용하는 것은 거의 구상 클래스라고 볼 수 있습니다.

```
abstract class Canine extends Animals{
    public void roam();
}
```

### **추상 메소드**

추상 클래스가 아닌 추상 메소드도 있습니다. 추상 메소드는 추상 클래스에서만 정의할 수 있습니다.

추상 메소드는 반드시 오버라이드해야하는 메소드로,메소드의 본체가 없는 메소드입니다.

```
public abstract void eat();
```

### **다형성**

여러 형태를 의미

```
public class MyAnimalTest{
    private Animal[] animals = new Animal[2];
    
    public static coid main (String[] args){
        // 선언
        Dog d = new Dog();
        Cat c = new Cat();
        
        // 배열 초기화
        animals[0] =  d;
        animals[1] = c;
        
        // 다형성1_Dog 객체, Cat 객체를 Animal로 해석
        for(int i = 0; i < animals.length; i++){
            animals[i].eat();
        }
        
        // 다형성2_Dog 객체, Cat 객체를 해당 객체로 해석
        d.eat();
        c.eat();
        
    }
}
```

Dog 클래스와 Cat 클래스가 Animal 클래스를 상속 받았고 eat() 메소드를 오버라이드 했다고 가정한 코드이다.

이때 다른 클래스의 객체를 갖고 있지만 같은 eat()메소드를 호출할 수 있다.

다형성 1과 다형성 2의 차이는 뒤에서 살펴보도록 하겠다.

#### **Object 클래스**

\- 자바에서 모든 클래스는 Object라는 클래스를 확장한 것

ex) Object 클래스의 멤버: equals(Object o), hashCode(), getClass(), toString()

\- 따라서 만약 원한다면... Object 클래스를 선언하고 다른 유형의 클래스를 모두 넣을 수 있음

\-> 그럼 왜 모든 메소드의 인자와 리턴 유형을 Object로 하지 않는가?

유형 안전성, 어떤 객체 유형에 대해 요구해야 할 것을 엉뚱한 객체에 요구하지 않도록 막는 것 때문.

이 예시가 위 코드의 다형성1의 부분이다.

\-> 이게 Animal 클래스의 메소드를 갖고 오는지, 각 하위 클래스의 메소드를 갖고 오진 않음

\-> Why? 배열에는 Animal 클래스 유형으로 저장이 된 것이기에 저 배열에는 해당 객체가 Dog, Cat이라는 정보가 없음

\-> 우리는 Dog과 Cat의 eat() 메소드를 사용하고 싶으나 오버라이딩된 메소드가 아닌, Animal의 eat() 메소드가 호출될 것이다.

즉, 컴파일러에서 어떤 메소드를 호출할 수 있는지 결정할 때 실제 객체 유형이 아닌 레퍼런스 유형을 기준으로 따진다.

#### **하향형변환** 

그럼, 만약 다형성 1의 부분에서 하위클래스의 메소드를 얻고 싶다면 어떻게 해야 하는가?

\-> 하향형변환 해주어야 함!

\-> 주의! 하향형변환은 상향형변환을 기반으로 하는 것임(즉, 하향형변환만 할 수는 없음)

```
Dog d = new Dog();
Animal a = d; // 상향형변환

a.eat() // Animal의 eat() 메소드 호출
Dog o = (Dog)a; // 하향형변환
o.eat(); // Dog의 eat() 메소드 호출
```

\+ 상위 클래스에 있는 메소드 호출 방법: 상위 클래스를 지칭하는 super 키워드 사용

### **다중 상속, 인터페이스**

만약 내가 2개의 클래스를 상속 받고 싶다면?

JAVA 에서는 다중 상속을 허용하지 않음

왜요..?

#### **죽음의 다이아몬드** 

## **\[CHAPTER 08\] 심각한 다형성**

### **추상 클래스**

클래스 중에는 인스턴스를 만들면 안 되는 것도 있음

\-> ex) 너무 추상적인 개념을 담고 있는 경우(ex hippo는 구체적인 클래스인데 Animal은 추상적인 클래스)

\-> 이런 경우에는 그냥 class가 아닌 abstract class(추상 클래스)를 만들면 됨

컴파일러에서는 추상 클래스의 인스턴스를 만드는것을 허용하지 않음

그렇다면 추상 클래스의 역할..이.. 뭐죠??

\-> 추상 클래스는 확장하지 않으면 거의 쓸모도 없고, 가치도 없고, 삶의 목적도 없습니다.

추상 클래스를 만들었을 때 실제 실행 중에 일을 처리하는 것은 그 **추상 클래스의 하위클래스 인스턴스** 입니다.

\+ 추상 클래스가 아닌 것을 구상 클래스라고 하는데, 우리가 사용하는 것은 거의 구상 클래스라고 볼 수 있습니다.

```
abstract class Canine extends Animals{
    public void roam();
}
```

### **추상 메소드**

추상 클래스가 아닌 추상 메소드도 있습니다. 추상 메소드는 추상 클래스에서만 정의할 수 있습니다.

추상 메소드는 반드시 오버라이드해야하는 메소드로,메소드의 본체가 없는 메소드입니다.

```
public abstract void eat();
```

### **다형성**

여러 형태를 의미

```
public class MyAnimalTest{
    private Animal[] animals = new Animal[2];
    
    public static coid main (String[] args){
        // 선언
        Dog d = new Dog();
        Cat c = new Cat();
        
        // 배열 초기화
        animals[0] =  d;
        animals[1] = c;
        
        // 다형성1_Dog 객체, Cat 객체를 Animal로 해석
        for(int i = 0; i < animals.length; i++){
            animals[i].eat();
        }
        
        // 다형성2_Dog 객체, Cat 객체를 해당 객체로 해석
        d.eat();
        c.eat();
        
    }
}
```

Dog 클래스와 Cat 클래스가 Animal 클래스를 상속 받았고 eat() 메소드를 오버라이드 했다고 가정한 코드이다.

이때 다른 클래스의 객체를 갖고 있지만 같은 eat()메소드를 호출할 수 있다.

다형성 1과 다형성 2의 차이는 뒤에서 살펴보도록 하겠다.

#### **Object 클래스**

\- 자바에서 모든 클래스는 Object라는 클래스를 확장한 것

ex) Object 클래스의 멤버: equals(Object o), hashCode(), getClass(), toString()

\- 따라서 만약 원한다면... Object 클래스를 선언하고 다른 유형의 클래스를 모두 넣을 수 있음

\-> 그럼 왜 모든 메소드의 인자와 리턴 유형을 Object로 하지 않는가?

유형 안전성, 어떤 객체 유형에 대해 요구해야 할 것을 엉뚱한 객체에 요구하지 않도록 막는 것 때문.

이 예시가 위 코드의 다형성1의 부분이다.

\-> 이게 Animal 클래스의 메소드를 갖고 오는지, 각 하위 클래스의 메소드를 갖고 오진 않음

\-> Why? 배열에는 Animal 클래스 유형으로 저장이 된 것이기에 저 배열에는 해당 객체가 Dog, Cat이라는 정보가 없음

\-> 우리는 Dog과 Cat의 eat() 메소드를 사용하고 싶으나 오버라이딩된 메소드가 아닌, Animal의 eat() 메소드가 호출될 것이다.

즉, 컴파일러에서 어떤 메소드를 호출할 수 있는지 결정할 때 실제 객체 유형이 아닌 레퍼런스 유형을 기준으로 따진다.

#### **하향형변환** 

그럼, 만약 다형성 1의 부분에서 하위클래스의 메소드를 얻고 싶다면 어떻게 해야 하는가?

\-> 하향형변환 해주어야 함!

\-> 주의! 하향형변환은 상향형변환을 기반으로 하는 것임(즉, 하향형변환만 할 수는 없음)

```
Dog d = new Dog();
Animal a = d; // 상향형변환

a.eat() // Animal의 eat() 메소드 호출
Dog o = (Dog)a; // 하향형변환
o.eat(); // Dog의 eat() 메소드 호출
```

\+ 상위 클래스에 있는 메소드 호출 방법: 상위 클래스를 지칭하는 super 키워드 사용

### **다중 상속, 인터페이스**

만약 내가 2개의 클래스를 상속 받고 싶다면?

JAVA 에서는 다중 상속을 허용하지 않음

왜요..?

#### **죽음의 다이아몬드** 

https://blog.kakaocdn.net/dn/P9TD3/btsugiwTXvB/Uy8gcCSeL2gXkClpWOVboK/img.jpg

1) burn() 메소드를 호출했는데, 어떤 상위 클래스의 멤버를 의미하는 지 모르는 경우

2) int i의 변수를 CDBurner와 DVDBurner 클래스에서 사용하는데, 값이 다른 경우, ComboDrive 클래스에서 두 값이 모두 필요한 경우

\-> 이런 상황 때문에 JAVA 에서는 다중 상속을 허용하지 않음

그럼.. 나는 어떻게 2개의 클래스를 상속 받을 수 있나요?

#### **인터페이스**

인터페이스는 100% 순수한 추상 클래스(멤버 메소드가 추상 메소드만 있는 경우)와 비슷함

```
// class가 아닌 interface로 제작
public interface Pet{...}

// extends 가 아닌 implements로 구현
public class Dog extends Canine implements Pet{...}
```

### **그럼, 그냥 클래스, 하위클래스, 추상 클래스, 인터페이스로 만들지 결정하는 방법이 뭔가요...**

1) 클래스를 새로 만들려고 할 때 그 클래스가 다른 어떤 유형에 대해서도 'A는 B다' 테스트를 통과할 수 없다면, **그냥 클래스**

2) 어떤 클래스의 더 구체적인 버전을 만들고 어떤 메소드를 오버라이드하거나 새로운 행동을 추가해야 한다면, **하위클래스**

3) 일련의 하위클래스에서 사용할 틀을 정의하고 싶다면, 그리고 모든 하위클래스에서 사용할 구현 코드가 조금이라도 있다면, 그리고 그 유형의 객체를 절대 만들 수 없게 하고 싶다면, **추상 클래스**

4) 상속 트리에서의 위치에 상관없이 어떤 클래스의 역할을 정의하고 싶다면, 다중 상속이 하고 싶다면, **인터페이스**

1) burn() 메소드를 호출했는데, 어떤 상위 클래스의 멤버를 의미하는 지 모르는 경우

2) int i의 변수를 CDBurner와 DVDBurner 클래스에서 사용하는데, 값이 다른 경우, ComboDrive 클래스에서 두 값이 모두 필요한 경우

\-> 이런 상황 때문에 JAVA 에서는 다중 상속을 허용하지 않음

그럼.. 나는 어떻게 2개의 클래스를 상속 받을 수 있나요?

#### **인터페이스**

인터페이스는 100% 순수한 추상 클래스(멤버 메소드가 추상 메소드만 있는 경우)와 비슷함

```
// class가 아닌 interface로 제작
public interface Pet{...}

// extends 가 아닌 implements로 구현
public class Dog extends Canine implements Pet{...}
```

### **그럼, 그냥 클래스, 하위클래스, 추상 클래스, 인터페이스로 만들지 결정하는 방법이 뭔가요...**

1) 클래스를 새로 만들려고 할 때 그 클래스가 다른 어떤 유형에 대해서도 'A는 B다' 테스트를 통과할 수 없다면, **그냥 클래스**

2) 어떤 클래스의 더 구체적인 버전을 만들고 어떤 메소드를 오버라이드하거나 새로운 행동을 추가해야 한다면, **하위클래스**

3) 일련의 하위클래스에서 사용할 틀을 정의하고 싶다면, 그리고 모든 하위클래스에서 사용할 구현 코드가 조금이라도 있다면, 그리고 그 유형의 객체를 절대 만들 수 없게 하고 싶다면, **추상 클래스**

4) 상속 트리에서의 위치에 상관없이 어떤 클래스의 역할을 정의하고 싶다면, 다중 상속이 하고 싶다면, **인터페이스**
