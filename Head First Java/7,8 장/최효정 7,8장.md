# 7,8장 정

# 7장

## 상속의 이해

---

**상속을 이용하여 설계할 때**

1. 공통적인 코드를 클래스로 묶음

2. 구체적인 클래스에 공통적인 클래스가 상위 클래스라는 걸 알려주면 됨

한 클래스가 다른 클래스를 상속 받는 것 = 하위클래스가 상위클래스로부터 상속받는다고 말함 = 하위 클래스가 상위클래스를 확장(extend) 한다고 얘기함

**오버라이딩**

- 하위 클래스에서 메소드의 역할을 변경하거나 확장할 필요가 있을 때 상속받은 메소드를 새로 정의하는 것

**클래스의 멤버 - 인스턴스 변수, 메소드**

인스턴스 변수는 오버라이드할 필요가 없기 때문에 오버라이드 하지 않음 > 특별한 행동을 정의하는 것이 아니기 때문에

## 메소드 오버라이딩

---

Q. 어떤 메소드를 오버라이드 해야할 까?

- 특정 하위 클래스 유형에만 적용되는 행동(메소드) 구현이 필요한지 결정함
- 공통적인 행동이 필요한 하위 클래스를 두개 이상 찾아서 추상화의 개념을 더 폭넓게 이용할 수 있는지 찾아봄

Q. 상속받았을 때 메소드를 호출하면 어떤 버전의 메소드가 호출될까?

- 객체 레퍼런스에 있는 메소드를 호출하면 그 객체 형식의 메소드 중에서 가장 구체적인 버전이 호출된다
    
    = 가장 아래 있는 것이 호출됨 
    
    = 상속 트리에서 가장 아래쪽에 있는 것을 의미한
    
- 매치되는 것을 찾을 때까지 상속 계층 구조를 따라 올라감

## "A는 B다" 관계 VS "A에는 B가 있다" 관계 (욕조 안의 아가씨)

---

Q. 어떤 것이 다른 것을 확장하는지 알고 싶다면 ‘A는 B다’ 테스트를 활용할 수 있음 

ex) 외과의사는 의사이다. 

## 수퍼클래스로부터의 상속

---

Q. 하위클래스에서 상위 클래스에 있는 버전의 메소드와 새로 오버라이드한 메소드를 다 사용하고 싶다면 어떻게 해야할까?

- super 키워드를 사용해서 상위클래스에 있는 버전의 메소드를 호출할 수 있다.

Q. 하위클래스는 상위클래스로부터 무엇을 상속받을 수 있나요?

- 하위클래스는 상위클래스의 member를 상속받는다.
    - member - 인스턴스 변수, 메소드
- 상위클래스에서는 멤버에 대한 접근 단계를 지정해 하위 클래스에서 상속받을 수 있는 것과 없는 것을 지정할 수 있다.
    1. private → private로 지정한 멤버는 상속되지 않음
    2. default
    3. protected
    4. public → public으로 지정한 멤버는 상속된다.

Q. 상속 활용하여 설계시의 주의점은?

1. 어떤 클래스가 다른 클래스(상위 클래스)를 더 구체화한 형식이라면 상속을 활용한다.
2. 여러 클래스에서 공유해야하는 어떤 행동(구현된 코드)이 있다면 상속을 활용한다.
3. 상위클래스와 하위클래스 사이의 관계가 위의 두가지 규칙에 위배된다면 상속을 사용하면 안된다.
4. 하위클래스와 상위클래스 사이에서 ‘A는 B다’ 관계가 성립되지 않는다면 상속 사용하면 안된다.
- 메소드는 오버라이드할 수 있지만 인스턴스 변수는 오버라이드할 수 없다.

## 상속 활용의 장점

---

Q. 상속 기능을 활용 시 어떤 장점? 

- 코드가 중복되는 것을 방지
- 상속받은 모든 클래스에서 새로운 변동사항이 자동으로 반영
- 하위클래스는 전혀 건드릴 필요가 없음
- 일련의 클래스를 위한 공통적인 규약(protocol)를 정의
- 특정 상위클래스 밑에 모여있는 모든 클래스에 상위 클래스에 들어있는 모든 메소드가 들어가게 할 수 있음.

## 다형성

---

Q. 다형성을 이용하는 이유

- 객체를 생성하고 대입하는 3가지 단계에서 레퍼런스 유형과 객체 유형이 같아야 하지만, 다형성을 활용하면 레퍼런스와 객체가 다른 유형이어도 됨
    1. 레퍼런스 변수 선언
    2. 객체 생성
    3. 레퍼런스와 객체 연결 
- 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있음
- 인자와 리턴 유형에 대해서도 다형성을 적용할 수 있음새로운 하위클래스 형식을 프로그램에 추가하더라도 코드를 굳이 바꿀 필요가 없음

## 오버라이딩 규칙

---

Q. 상위클래스의 메소드를 오버라이드할 때 따라야 하는 규칙은 무엇인가요?

- 오버라이드하는 메소드의 인자와 리턴 형식은 외부에서 보기에 상위클래스에 있는 오버라이드를 당하는 메소드와 완벽하게 일치해야함
- 메소드는 계약서임
1. 인자는 똑같아야 하고, 리턴 유형은 호환가능 해야함
2. 메소드를 더 접근하기 어렵게 만들면 안됨 → public을  private로는 안됨 

## 메소드 오버로딩

---

Q. 메소드 오버로딩이란 ? 

- 이름이 같고 인자 목록이 다른 메소드 두개를 만드는 것임
- 다형성과는 관계가 없음
- 로버로딩된 메소드는 메소드 이름만 같을 뿐 서로 다른 메소드임
1. 리턴 유형이 달라도 됨
2. 리턴 유형만 바꿀 수는 없음 → 리턴유형과 무관하게 인자 목록 반드시 변경해야함
3. 접근 단계를 마음대로 바꿀 수 있음

# 8장

## 인스턴스를 만들 수 없는 클래스

---

클래스 중에는 인스턴스를 만들면 안되는 것도 있음 → animal 객체는 필요하지 않으니

- 어떤 클래스의 인스턴스를 만들 수 없게 하는 간단한 방법
    
    → 특정 유형에 대해 “new” 키워드를 못 쓰게 하는 방법 
    
    = 클래스를 abstract으로 지정하면 컴파일러에서 그 유형의 인스턴스를 만드는 코드를 허용하지 않음
    
- abstract type = 추상 유형
- 

## 추상 클래스 (인스턴스를 만들 수 없습니다)

---

추상 클래스 VS 구상 클래스

- 추상 클래스 : 아무도 그 클래스의 새로운 인스턴스를 만들 수 없는 클래스
- 구상 클래스 : 인스턴스를 만들어도 될 만큼 구체적인 클래스
    
    → 추상 클래스가 아닌 것
    
    → 그 유형의 객체를 만들어도 됨
    
    - 상위 클래스가 추상 클래스여도 하위 클래스 객체를 상위 클래스 레퍼런스에 대입하는 것은 가능함

**추상 클래스**

- 확장하지 않으면 쓸모 없음
- 실제 실행 중에 일을 처리하는 것은 그 추상 클래스의 하위클래스 인스턴스
- 

## 추상 메소드 (반드시 구현해야 합니다)

---

메소드도 abstract으로 지정할 수 있음!

**추상 클래스**

- 만드시 확장해야하는 클래스

**추상 메소드**

- 반드시 **오버라이드** 해야하는 메소드
- 추상 클래스의 행동 가운데 일부 혹은 전부에 대해 더 구체적인 하위클래스에서 구현되지 않으면 의미가 없다는 것을 말함
- 추상 메소드는 몸통이 없음

- public abstract void eat();
- 추상 클래스가 아닌 클래스에 추상 메소드를 집어넣을 수는 없음
    
    → 클래스에 추상 메소드가 하나라도 있으면 그 클래스도 추상 클래스로 지정
    
    → 추상 클래스 안에 추상 메소드와 추상 메소드가 아닌 메소드를 모두 집어넣는 것은 가능
    

Q. 추상 메소드는 왜 있죠?

- 일련의 하위클래스를 위한 규약의 일부를 정의하기 위한 것

Q. 어떤 장점이 있는데? 

- 다형성!
- 추상메소드는 다형성을 활용하기 이ㅜ해 “ 이 유형에 속하는 모든 하위클래스 유형에는 이 메소드가 있어야 한다”는 것을 지정하기 위해 필요한 것

## Object 클래스

---

Object 클래스 : 모든 클래스의 어머니 =  모든 것의 상위클래스

- 자바에서 모든 클래스는 Object 클래스를 확장한 것
- 어떤 클래스를 만들어도 그 클래스는 반드시 Object 클래스를 확장한 클래스
- 명시적으로 다른 클래스를 확장하지 않은 클래스는 자동으로 object 를 확장한 클래스로 정의됨

 

## ArrayList에서 객체 꺼내는 방법

---

- Snowboard는 Snowboard 아니면 Object로 간주
- ArrayList<Object>에 객체를 집어넣으면 그 객체는 원래의 유형과는 무관하게 Object로만 처리할 수 있음
- ArrayList <Object>로부터 레퍼런스를 받아오면 그 레퍼런스는 항상 Object 유형임

## 객체 레퍼런스 캐스팅

- 객체에 있는 메소드를 호출하려면 그 메소드가 레퍼런스 변수의 클래스에 들어가있어야 함
- 컴파일러에서는 레퍼런스가 참조하는 실제 객체의 클래스가 아닌 레퍼런스 변수를 선언할때 지정한 유형의 클래스를 확인한다

## 죽음의 다이아몬드

- 상위 클래스가 두개 있어야 하는 상황에서 일어나는 문제
- 다중 상속을 쓰면 하나의 메소드, 인스턴스 변수를 여러군데에서 사용하는데 값이 다른 경우에, 어떤 메소드, 혹은 어떤 변수값을 가져오는지에 대한 문제가 발생함

## 인터페이스 사용 방법

---

- 인터페이스  → 다중 상속의 해결책
- 모든 메소드를 추상 메소드로 만들면 하위 클래스에서 반드시 메소드를 구현해야하므로 어떤 것을 호출해야하는지 결정 못하는 문제 X
- 자바 인터페이스는 100% 순수한 추상 클래스와 비슷
- interface  - implements로 구현
- 한 클래스에서 인터페이스 여러개를 구현할 수도 있음