## **상속(Inheritance)**

-   클래스 A를 클래스 B가 상속받는다면, A는 상위클래스(superclass), B는 하위클래스(subclass)이다.
    -   하위클래스는 상위클래스의 메소드를 상속받는다.
    -   상위클래스는 하위클래스보다 더 추상적이다.
    -   하위클래스는 상위클래스보다 더 구체적이다.
    -   하위클래스가 상위클래스를 확장(extend)한다.
-   상속의 장점
    1.  코드 중복 방지, 변동사항 자동 반영
    2.  일련의 클래스를 위한 공통적 규약(Protocol) 정의  
        ➡️ 특정 상위클래스 밑에 있는 모든 클래스에 상위클래스의 상속 가능한 모든 메소드가 들어가기 때문
    3.  다형성 활용 가능
 
<br>

#### 상속의 설계 방법

1.  공통적 속성과 행동을 가지는 객체 탐색
    -   공통적 속성 ➡️ 행동 추상화 가능
    -   각 유형의 연관 ➡️ 상속 트리 내 관계 정의 가능
2.  공통적 상태와 행동 나타내는 클래스 설계  
    ➡️ 공통적인 상위클래스
3.  특정 하위클래스 유형에만 적용되는 행동이 필요한지 결정  
    ➡️ 메소드 구현
    -   하위클래스에서 어떤 메소드를 오버라이드할지
4.  공통적 행동이 필요한 하위클래스를 2개 이상 탐색  
    ➡️ 추상화 개념의 더 넓은 활용
    -   기존 상위클래스와 하위클래스 사이에 클래스 하나가 더 필요할 수 있다.
5.  클래스 계층 구조 완성

![image](https://github.com/GDSC-SWU/2023-JAVA-Study/assets/68212300/76132d16-39a0-49f0-8f4b-660b4f4cb4fd)
출처 - Homepages of UvA/FNWI
-   클래스 계층 구조의 예이다.
-   Object는 가장 상위 클래스로, 하위클래스들은 모두 Object를 상속받는다.
-   Vowel & Consonant와 Digit은 Character에 해당하는 공통적인 속성과 행동을 가지지만, Letter에 해당하는 속성과 행동은 Vowel & Consonant만 가진다.
 
<br>

#### 메소드 호출

-   객체 레퍼런스에 있는 메소드를 호출하면 그 객체 형식의 메소드 중 가장 구체적인 버전이 호출된다.  
    ➡️ 상속 트리에서 가장 아래쪽에 있는 것이 호출된다.
-   JVM에서는 자식 클래스에서 부모 클래스로 올라가며 메소드를 찾는다.  
    ➡️ 상속 트리를 따라 올라가며 찾는다.
 
<br>

#### A는 B다 관계

-   상속 트리를 잘 설계했다면, **'하위클래스 A는 상위클래스 B다'**라는 관계가 성립한다.
-   이 테스트는 상속 트리 어느 곳에서도 성립한다.
    -   A -> B -> C 방향으로 상속하고 있다면,  
        ➡️ C는 B이다. / B는 A이다. / C는 A이다. 가 모두 성립한다.
-   상속에서 'A는 B다' 관계는 한 방향으로만 작동한다.
-   'A에는 B가 있다' 관계는 상속 관계가 아닌, 클래스 A 안에 레퍼런스 변수 B가 인스턴스 변수로 포함될 때의 관계일 수 있습니다.
 
<br>

#### 상속 설계 시 주의점

-   접근 단계에 따라 멤버의 상속 여부가 결정된다.
    -   public으로 지정한 멤버 ➡️ 상속
    -   private으로 지정한 멤버 ➡️ 상속X
-   상속을 활용하는 경우
    1.  어떤 클래스가 다른 클래스를 더 구체화한 형식이라면
    2.  여러 클래스에서 공유해야 하는 어떤 행동(코드)이 있다면
-   상속을 사용하면 안 되는 경우
    1.  위 상속을 활용하는 두 경우가 아니라면
    2.  하위클래스와 상위클래스에서 'A는 B다' 관계가 성립하지 않는다면
-   상속 불가능한 클래스
    1.  public으로 선언하지 않은 클래스  
        ➡️ 해당 클래스와 같은 패키지 안에서만 하위 클래스 생성 가능
    2.  final로 지정한 클래스  
        ➡️ 상속 계층에서 맨 마지막 클래스가 된다.  
        ➡️ 보안상 오버라이딩 금지하는 경우 (ex. String)
    3.  생성자가 모두 private으로 지정된 클래스

---

## **다형성**

하나의 코드가 여러 자료형으로 구현되어 실행

-   다형성 활용 시 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다.
-   다형적 배열 생성 가능
-   인자와 리턴 유형에 대한 다형성 적용 가능
-   새로운 하위클래스 형식을 추가해도 코드를 변경할 필요가 없다.
 
<br>

#### 레퍼런스 변수 생성 시 다형성 활용

다형성 활용 시 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있다.

-   Animal 클래스가 Dog 클래스의 상위 클래스인 경우

```
Dog myDog = new Dog();
Animal myDog = new Dog();
```

-   다형성 활용 시 레퍼런스 유형을 실제 객체 유형의 상위클래스 유형으로 지정할 수 있으므로 레퍼런스 유형과 객체 유형이 달라도 된다.  
    ➡️ Dog 자리에 Animal이 들어갈 수 있다.
 
<br>

#### 다형적 배열 생성

-   Animal 유형의 배열에 Animal 하위클래스에 속하는 모든 객체를 삽입할 수 있다.
-   배열의 모든 원소에 대해 Animal의 메소드 호출 시 각 객체마다 올바른 메소드를 호출한다.

```
Animal[] animals = new Animal[5];
animals[0] = new Dog();
animals[1] = new Cat();
animals[2] = new Wolf();
animals[3] = new Hippo();
animals[4] = new Lion();

for (int i = 0; i < animals.length; i++) {
	animals[i].eat();
    	animals[i].roam();
}
```
 
<br>

#### 메소드 선언 시 다형성 활용

인자와 리턴 유형에 대해 다형성 적용이 가능

```
class Vet {
	public void giveShot(Animal a) {
    	a.makeNoise();
    }
}
```

```
class PetOwner {
	public void start() {
    	Vet v = new Vet();
        Dog d = new Dog();
        Hippo h = new Hippo();
        v.giveShot(d);
        v.giveShot(h);
    }
}
```

-   giveShot()은 모든 Animal을 인자로 받을 수 있다.  
    ➡️ Animal의 새로운 하위클래스 형식을 추가해도 코드를 변경할 필요가 없다.
-   각 객체에 따라 올바른 메소드를 호출한다.
 
<br>

#### 오버라이드

하위클래스에서 메소드의 역할을 변경하거나 확장할 필요가 있을 때 상속받은 메소드를 새로 정의하는 것

-   인스턴스 변수는 오버라이드할 필요가 없으므로 오버라이드 하지 않는다.  
    ➡️ 인스턴스 변수에서 특정 행동을 정의하는 것이 아니기 때문
-   인자는 같아야 하고, 리턴 유형은 호환 가능해야 한다.
-   오버라이딩 시 접근 단계는 유지하거나 완화시켜야 한다.  
    ➡️ public -> private 불가
-   오버로딩(overloading)과는 전혀 다른 개념이다.
    -   인자 목록과 리턴 유형 제한
        1.  인자 목록이 같은 경우 ➡️ 리턴 유형이 달라야 한다.
        2.  인자 목록이 다른 경우 ➡️ 리턴 유형이 같거나 다르거나 상관 없다.
    -   오버로딩 시 접근 단계가 변경되어도 된다.
-   하위 클래스에서 오버라이딩한 버전과 상위 클래스의 버전을 둘 다 사용할 경우  
    ➡️ **super** 키워드 사용
-   특정 메소드만 오버라이딩 금지하고 싶은 경우  
    ➡️ 해당 메소드에 **final** 지정
