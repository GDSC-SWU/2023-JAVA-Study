## 스택과 힙
- 힙: 객체가 저장되는 곳 ➡️ 가비지 컬렉션 기능이 있는 힙
- 스택: 메소드 호출과 지역 변수가 저장되는 곳

### 인스턴스 변수와 지역 변수
##### 인스턴스 변수
- 클래스 내에서 선언한 변수
	- 클래스 내 메소드에서 선언한 변수는 인스턴스 변수가 아님
- 필드
- 인스턴스 변수는 그 변수가 속한 객체 안에서 삶
	- 변수를 저장하기 위한 공간이 객체 안에 마련
	- 만약 인스턴스 변수가 레퍼런스 변수라면, 레퍼런스 변수가 들어갈 공간만 확보
##### 지역 변수 (임시 변수)
- 메소드 안에서 선언한 변수
- 메소드 매개변수도 지역 변수에 포함
- 메소드가 스택에 들어있는 동안만 살아있음 (임시 변수)

### 스택 시나리오
- 메소드 호출 시 호출 스택(call stack) 맨 위에 올라감
	- 스택 맨 위에 있는 메소드는 항상 현재 실행 중인 메소드
- 실제로 스택에는 스택 프레임이 들어감
	- 스택 프레임: 실행 코드, 메소드 상태(모든 지역 변수의 값) 포함
- 지역 변수가 객체에 대한 레퍼런스인 경우에는 변수(레퍼런스)만 스택에 저장됨
	- 객체 자체는 힙 안에 저장

## 생성자
- 객체를 생성할 때 실행되는 코드 포함(`new`키워드 사용 시)
	- 객체를 실제로 사용하기 전 필요한 작업 처리 가능
	- 객체 상태 초기화 등
- 직접 만들지 않아도, 모든 클래스에는 생성자가 존재
- 생성자는 리턴 유형이 없음 (➡️ 메소드와의 차이)
- 생성자에서 인스턴스 변수값을 설정하지 않으면 초기값으로 설정

> 인스턴스 변수 초기값
> 숫자: 0 / 0.0
> 부울: fasle
> 레퍼런스: null

### 생성자 오버로딩
- 클래스에 인자 목록이 서로 다른 생성자가 두 개 이상 작성될 수 있음
- 서로 인자 목록이 달라야 함 (순서, 인자 유형)
### 생성자와 접근 제한자
- public / private / default 가능

## 상위 클래스의 생성
### 하위 클래스의 객체 생성 시 힙에 들어가는 구조
- 상속 트리 전체에 걸쳐 축적된 객체 내 모든 인스턴스 변수에 대한 공간 부여
- `new`로 생성한 객체 뿐만 아니라, 그 상위 클래스들마다 객체가 하나씩 더 생기는 격
![Pasted image 20231002163507](https://github.com/GDSC-SWU/2023-JAVA-Study/assets/68212300/64fe5816-197d-4172-a913-9884ebfaf366)

### 생성자 연쇄
- 생성자 실행 시 Object 생성자에 도달할 때까지 상속 계층 올라가며 각 상위 클래스의 생성자 호출
![Pasted image 20231002164214](https://github.com/GDSC-SWU/2023-JAVA-Study/assets/68212300/b6c5b2b7-ac55-43d7-9f7c-4a9529eda5e8)
1. `new Hippo()` 호출
	- Hippo 생성자의 스택 프레임이 스택 가장 위에 삽입
2. `Hippo()`에서 상위 클래스 Animal 생성자 호출
	- Animal 생성자의 스택 프레임이 스택 가장 위에 삽입
3. `Animal()`에서 상위 클래스 Object 생성자 호출
	- Object 생성자의 스택 프레임이 스택 가장 위에 삽입
4. `Object()` 종료
	1. 해당 스택 프레임이 스택에서 제거됨
	2. 다시 Animal 생성자로 돌아가 `Object()` 바로 다음 코드 실행
- 하위 클래스 생성자가 종료되기 전에 상위 클래스 생성자가 반드시 종료되어야 함
### 상위 클래스 생성자 호출
- `super()` 호출
- 직접 super() 호출하지 않으면 컴파일러가 알아서 생성
	- 단, 상위 클래스가 인자가 없는 생성자를 가지고 있지 않는 경우에 `super()` 미호출시 컴파일 오류
- `super()` 호출하는 선언문은 모든 생성자의 첫번째 선언문이어야 함
```java
// OK
public Boop(int i) {
	super();
	size = i;
}

// OK ➡️ 컴파일러에서 자동으로 맨 앞에 super() 추가
public Boop(int i) {
	size = i;
}

// Error
public Boop(int i) {
	size = i;
	super();
}
```
### 오버로드된 생성자 호출
- 여러 생성자 내에 중복 코드가 존재하는 경우
- `this()`로 객체 내 생성자 호출
	- `this`: 현재 객체에 대한 레퍼런스
- `this()`는 생성자의 첫번째 선언문으로만 작성 가능
	- 따라서, 한 생성자 안에 `super()`, `this()`가 동시에 들어갈 수는 없음

## 객체의 라이프사이클
### 변수의 삶
#### 1. 지역 변수
- 해당 변수를 선언한 메소드 안에서만
- 객체 내 메소드의 매개변수도 마찬가지
#### 2. 인스턴스 변수
- 객체가 살아있는 동안
### 지역 변수의 삶과 영역
#### 삶 (life)
- 변수의 상태가 유지되는 기간
- 스택 프레임이 스택에 들어있는 동안
- 메소드 종료할 때까지
	- 스택 프레임이 스택에서 제거되는 시점 ➡️ 메소드 종료 시점
#### 영역 (scope)
- 변수에 접근할 수 있는 영역
- 변수를 선언한 메소드 내부로 제한
- 메소드에서 다른 메소드 호출 시, 변수는 살아있지만 영역 밖이기 때문에 사용 불가
### 레퍼런스 변수
- 레퍼런스 변수가 영역 밖이더라도 살아있다면 그 레퍼런스 변수가 참조하는 객체는 힙 안에 존재
- 객체에 대한 마지막 레퍼런스가 사라지면 객체는 GC(Garbage Collection)의 대상이 됨
	- 메모리가 부족해지면 GC 대상 중 일부 또는 전체를 삭제
#### 객체 레퍼런스 제거 방법
1. 레퍼런스가 영역을 영원히 벗어남 (메소드 종료 시)
	```java
	void go() {
		Life z = new Life();
	}
	```
1. 레퍼런스에 다른 객체 대입
	```java
	Life z = new Life();
	z = new Life();
	```
1. 레퍼런스를 null로 설정 (해제)
	``` java
	Life z = new Life();
	z = null;
	```
