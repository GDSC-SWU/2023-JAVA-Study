#### **스택**

메소드 호출과 지역 변수가 사는 곳

지역 변수가 객체에 대한 레퍼런스인 경우에는 변수(레퍼런스, 리모컨)만 스택에 들어감

#### **힙**

모든 객체가 사는 곳

**생성자**

어떤 클래스 유형에 대해 new 키워드를 사용할 때 실행되는 코드

클래스명과 같아야 하며 리턴 유형은 없어야 함(리턴 유형이 없는 부분이 메소드와 다른 부분)

#### **생성자 연쇄**

새로운 객체를 만들 때 객체의 상속 트리에 들어있는 모든 생성자가 실행되어야 함

new 키워드를 사용하는 것은 모든 생성자 연쇄 반응을 시작시키는 것

이런 과정을 생성자 연쇄라고 함

각 생성자가 부모 생성자를 부를 때 스택 위에 쌓이고, 생성자의 일이 끝나면 스택에서 사라지는 과정이 일어남

\* 굳이 부모 생성자를 호출하지 않아도 객체 생성시 알아서 컴파일러에 의해 생성되지만, 상위클래스 생성자를 호출하고 싶다면, super 키워드를 사용하면 된다.

\* 부모 전에 자식이 생성될 수는 없으므로 super()를 호출하는 선언문은 모든 생성자의 첫번째 선언문이어야 함

\* 같은 클래스에 있는 다른 생성자를 호출할 때는 this()를 사용하면 됨

\* this()는 생성자에서만 호출할 수 있으며 반드시 그 생성자의 첫번째 선언문이어야만 하기에 super()와 같이 쓰일 수 없음

#### **객체의 생명**

**1) 지역 변수**

해당 변수를 선언한 메소드 안에서만 살 수 있음

why?

메소드는 스택에 저장

메소드의 지역변수는 메소드와 함께 스택에 저장

따라서 메소드가 사라질 때(해당 메소드의 스택 프레임이 사라질 때) 해당 지역 변수도 함께 스택에서 나가게 됨

+

**지역 변수의 삶과 영역**

삶: 스택 프레임이 스택에 들어있는 한

영역: 코드의 블록 기준

**2) 인스턴스 변수**

객체가 살아있는 동안 계속 살 수 있음

why?

인스턴스 변수는 클래스의 필드로, 힙에 저장됨

따라서 해당 객체를 참조하는 레퍼런스 변수만 있다면 객체가 살아있을 수 있고

그렇다면 해당 객체 안에 함께 저장된 인스턴스 변수는 힙 안에 객체가 살아있다면 계속 살아있을 수 있음

+

**객체가 가비지 컬렉션의 대상이 되는 순간?**

1) 레퍼런스가 영원히 영역을 벗어나는 것

아예 메소드 안에 들어가 있는 지역 변수로 레퍼런스 변수를 선언한 경우 -> 메소드가 죽으면 레퍼런스 변수도 죽음

2) 레퍼런스에 다른 객체를 대입한 경우

원조 객체를 가리키는 레퍼런스 변수가 없다면 해당 객체는 가비지 컬렉션의 대상이 됨

3) 레퍼런스를 직접 null로 설정

2번과 같은 이유로 대상이 됨

**기본값**

프로그래머가 직접 기본값을 지정하지 않아도 인스턴스 변수에는 자동으로 기본값이 지저됨

원시 유형의 기본값은 각 타입에 맞춰 정해져있고, 객체에 대한 레퍼런스의 기본값은 null 임
