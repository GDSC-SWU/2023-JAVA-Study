## \[CHAPTER 07\] 상속과 다형성  
  

### **상속 트리를 설계하는 방법**

1\. 공통적인 속성(멤버 변수)와 행동(멤버 함수)가 들어있는 객체를 찾아보기

2\. 특정 하위클래스 유형에만 적용되는 행동이 필요한지 결정하기

3\. 공통적인 행동이 필요한 하위 클래스를 두 개 이상 찾아보기

\* 추상화의 개념을 더 폭넓게 활용할 수 있을지 확인하기

4\. 클래스 계층 구조 완성하기

#### **Tip!**

이때, 상속트리를 확인하게 된다면, 상위클래스가 하위클래스보다 추상적이고, 하위클래스가 상위클래스보다 구체적임을 확인할 수 있다.

1) 혹시 상위클래스와 하위클래스를 결정하기 어렵다면, A는 B다 라는 문장이 맞게 성립한다면, B를 상위클래스로, A를 하위클래스로 정하는 게 좋을 것이다.

2) 상속에서의 "A는 B다" 관계는 한 방향으로만 작동합니다. 이게 맞는지를 확인하면 상속 구조를 제대로 만들었는지 알 수 있다.

#### **주의점!**

1) 행동을 재사용하는 데 있어서 상속이라는 방법이 무조건 최선의 방법은 아니다 -> 디자인 패턴 공부

2) 만약 상위클래스와 하위클래스의 관계가 위에 있는 두 가지 규칙에 위배된다면 어떤 코드를 다른 클래스에서 재사용할 수 있다는 이유만으로 상속을 사용하면 안된다.

#### **장점!**

1) 코드가 중복되는 것을 방지할 수 있음

2) 행동을 수정할 때 모든 클래스의 행동을 수정하지 않고, 상위클래스의 행동만을 수정하면 됨

2) 일련의 클래스를 위한 공통적인 규약을 정의함

#### **상속이 불가능한 경우!**

1) public 이 아닌 접근제어를 갖고 있는 클래스의 경우

2) final이라는 키워드 변경자로 클래스 지정

3) 클래스 생성자가 private인 경우

#### **오버라이드 규칙**

1) 인자는 똑같아야 하고, 리턴 유형은 호환 가능해야 함

즉, 리턴 클래스가 리턴하려는 객체의 상위 클래스면 호환이 되기에 문제가 되지 않음

2) 메소드를 더 접근하기 어렵게 만들 수는 없음

public -> private 로 상위 클래스에서 public으로 정의해둔 것을 private로 변경할 수는 없음

**\* 메소드 오버로딩**

오버라이드와 오버로딩은 다르다. 오버라이딩은 상속 관계에서 발생하는 거지만, 오버로딩은 클래스 내에 같은 이름을 가진 메소드를 만든다는 개념이기 때문.

오버로딩의 규칙

1) 리턴 유형이 달라도 됨

2) 리턴 유형만 바꿀 수는 없고, 인자의 개수나 타입에 변화가 있어야 함

3) 접근 단계를 마음대로 바꿀 수 있음

---

### **객체 생성과 대입**

```
Dog myDog = new Dog();
```

1) 레퍼런스 변수 선언

```
Dog myDog
```

2) 객체 생성

```
new Dog()
```

3) 객체와 레퍼런스 연결

```
Dog myDog = new Dog();
```

\-> 이때 중요한 것은 레퍼런스 유형과 객체 유형이 똑같아야 한다는 것

\-> 하지만, **다형성**을 활용하면 레퍼런스와 객체가 다른 유형(-> 실제 객체 유형의 상위클래스 유형)이어도 됨

\->인자와 리턴 유형에 대해서도 다형성을 적용할 수 있음

```
Animal myDog = new Dog();
```
